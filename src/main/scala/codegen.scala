/*
 *  Schema to source-code converter for VL4S
 *  RW Penney, November 2017
 */

//  Copyright (C) 2017, RW Penney
//  This file is part of VL4S.
//
//  VL4S is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Foobar is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with VL4S.  If not, see <http://www.gnu.org/licenses/>.

package uk.rwpenney.vl4s.gen

import java.io.{ OutputStream, PrintWriter }
import scala.annotation.tailrec


trait TypeCoder {
  def typename: String
  def targetname: String = typename
  def toCode: String
}


trait ParentCoder {
  def makeHelperClasses(roots: Seq[VLtypeDefn]): Option[String] = {
    val locals = VLtypeDefn.expandDependencies(roots)

    // FIXME - insert actual type definition
    if (locals.nonEmpty) {
      Some(locals.map { vltype =>
        s"trait ${CodeGen.toCodeable(vltype).typename} // ${vltype.getClass.getName}"
        } . mkString("", "\n", "\n\n"))
    } else {
      None
    }
  }
}


class EmptyCoder extends TypeCoder {
  def typename = "[EMPTY]"
  def toCode = ""
}


class BareCoder(defn: VLbareType) extends TypeCoder {
  def typename = CodeGen.cleanClassName(
                    CodeGen.mapBareTypes.getOrElse(defn.name, defn.name))
  def toCode = ""
}


class ArrayCoder(defn: VLarrayOf) extends TypeCoder {
  val itemtype = CodeGen.toCodeable(defn.vltype).targetname

  def typename = s"Seq[${itemtype}]"
  def toCode = ""
}


class EnumCoder(defn: VLenumDefn) extends TypeCoder {
  def typename = defn.name

  def toCode: String = {
    val terms = defn.values.map { term =>
      s"""|  final val ${cleanName(term)} = new ${typename} {
          |    val term: String = "${term}" }"""
    } . mkString("\n")

    s"""sealed trait ${typename}
    |object ${typename} extends ${typename} {
    ${terms}
    |}
    |""" . stripMargin
  }

  def cleanName(orig: String): String =
    orig.replaceAll("-", "_")
}


class AnyOfCoder(defn: VLanyOf) extends TypeCoder with ParentCoder {
  def typename = CodeGen.cleanClassName(defn.name)

  def toCode: String = {
    val options = defn.options.map { opt => {
      val opttype = CodeGen.toCodeable(opt).targetname
        s"""|  implicit def from${opttype}(_arg: ${opttype}) = {
            |     // ${opt.getClass.getName}
            |    new ${typename} { val dummy = 1 } }""" . stripMargin
      }
    } . mkString("\n")
    // FIXME expand any embedded VLopDefn objects

    Seq(makeHelperClasses(defn.options),
        Some(s"sealed trait ${typename}"),
        Some(s"object ${typename}Implicits extends ${typename} {"),
        Some(options),
        Some("}")) . flatten . mkString("", "\n", "\n\n")
  }
}


class TupleCoder(defn: VLtupleDefn) extends TypeCoder with ParentCoder {
  def typename = CodeGen.cleanClassName(defn.name)

  def toCode: String = s"sealed trait ${typename} // ${defn.name}"
  // FIXME - more here
}


class OperatorCoder(defn: VLopDefn) extends TypeCoder with ParentCoder {
  def typename = CodeGen.cleanClassName(defn.name)

  val fieldTypes = defn.properties.map { prop =>
    ( prop.name, CodeGen.toCodeable(prop.vltype).targetname )
  } . toMap
  val fieldNames = defn.properties.map { prop =>
    ( prop.name, CodeGen.mapReserved.getOrElse(prop.name, prop.name) )
  } . toMap

  def toCode: String = {
    val fields = defn.properties.map { prop =>
      s"    _${fieldNames(prop.name)}: Option[${fieldTypes(prop.name)}] = None"
    } . mkString(",\n")

    val modifiers = defn.properties.map { prop =>
      val field = fieldNames(prop.name)
      s"  def ${field}(__arg: ${fieldTypes(prop.name)}): ${typename}" +
            s" = this.copy(_${field} = Some(__arg))"
    } . mkString("", "\n", "\n")

    Seq(makeHelperClasses(defn.properties.map { _.vltype }),
        Some(s"case class ${typename}("),
        if (fields.nonEmpty) Some(s"\n${fields}") else None,
        Some(") {\n"),
        if (modifiers.nonEmpty) Some(modifiers) else None,
        Some("}\n\n")) . flatten . mkString("")
    // FIXME - extract description as scaladoc comment
  }
}


class ObjRefCoder(defn: VLobjRef) extends TypeCoder {
  def typename = CodeGen.cleanClassName(defn.alias)
  override def targetname = CodeGen.cleanClassName(defn.target.name)
  def toCode = {
    s"""object ${defn.name} {
    |  type ${typename} = ${targetname}
    |}
    |import ${defn.name}._
    |""" . stripMargin
  }
}


class CodeGen(val stream: OutputStream) {
  def apply(schema: VLschema) {
    val pw = new PrintWriter(stream)

    val warning = "/* AUTOGENERATED by VL4S - do not edit by hand */\n"

    pw.print(warning)
    pw.print("""
             |package uk.rwpenney.vl4s
             |
             |import scala.language.implicitConversions
             |
             |""" . stripMargin)

    CodeGen.makeTypeRefs(schema) match {
      case Some(typerefs) => pw.print(typerefs)
      case None =>
    }

    schema.types.foreach { vltype =>
      vltype match {
        case or: VLobjRef =>
        case _ => {
          val codeable = CodeGen.toCodeable(vltype)
          pw.print("\n")
          pw.print(codeable.toCode)
        }
      }
    }

    pw.print("\n" + warning)
    pw.close()
  }
}


object CodeGen {
  def toCodeable(vltype: VLtypeDefn): TypeCoder = {
    vltype match {
      case bare: VLbareType =>  new BareCoder(bare)
      case arr: VLarrayOf =>    new ArrayCoder(arr)
      case enum: VLenumDefn =>  new EnumCoder(enum)
      case ao: VLanyOf =>       new AnyOfCoder(ao)
      case tpl: VLtupleDefn =>  new TupleCoder(tpl)
      case op: VLopDefn =>      new OperatorCoder(op)
      case or: VLobjRef =>      new ObjRefCoder(or)
      case _ =>                 new EmptyCoder
    }
  }

  def makeTypeRefs(schema: VLschema): Option[String] = {
    val objrefs = schema.objRefs

    if (objrefs.nonEmpty) {
      Some((Seq("object TypeRefs {") ++
            objrefs.map { toCodeable(_) } .
              map { codeable => 
                s"  type ${codeable.typename} = ${codeable.targetname}" } ++
            Seq("}", "import TypeRefs._")) . mkString("", "\n", "\n"))
    } else {
      None
    }
  }

  // Conversion for VL properties which class with Scala reserved words
  val mapReserved = Map(
    "type" -> "vtype"
  )

  val mapBareTypes = Map(
    "boolean" ->  "Boolean",
    "null" ->     "Unit",
    "number" ->   "Double",
    "ref" ->      "Any",      // FIXME - improve decoding
    "string" ->   "String"
  )

  def cleanClassName(orig: String): String =
    orig.map {
      case '<' => '_'
      case '>' => '_'
      case c =>   c
    }
}
