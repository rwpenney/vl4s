/*
 *  Schema to source-code converter for VL4S
 *  RW Penney, November 2017
 */

package uk.rwpenney.vl4s.gen

import java.io.{ OutputStream, PrintWriter }


trait TypeCoder {
  def toCode: String
}


class EnumCoder(defn: VLenumDefn) extends TypeCoder {
  def toCode: String = {
    val terms = defn.values.map { term =>
      s"""|  case object ${cleanName(term)} extends ${defn.name}Enum {
          |    val term: String = "${term}" }"""
    } . mkString("\n")

    s"""sealed trait ${defn.name}Enum
    |case object ${defn.name} {
    ${terms}
    |}
    |""" . stripMargin
  }

  def cleanName(orig: String): String =
    orig.replaceAll("-", "_")
}


class OperatorCoder(defn: VLopDefn) extends TypeCoder {
  def toCode: String = {
    val classname = CodeGen.cleanClassName(defn.name)

    val fieldnames = defn.properties.map { prop =>
      ( prop.name, CodeGen.mapReserved.getOrElse(prop.name, prop.name) )
    } . toMap

    val fieldtypes = defn.properties.map { prop =>
      ( prop.name, CodeGen.mapVLtypes.getOrElse(prop.vltype, prop.vltype) )
    } . toMap

    val fields = defn.properties.map { prop =>
      s"|    _${fieldnames(prop.name)}: ${fieldtypes(prop.name)}"
    } . mkString(",\n")

    val modifiers = defn.properties.map { prop =>
      val field = fieldnames(prop.name)
      s"|  def ${field}(__arg: ${fieldtypes(prop.name)}): ${classname}" +
            s" = this.copy(_${field} = __arg)"
    } . mkString("\n")

    s"""case class ${classname}(
    ${fields}) {
    ${modifiers}
    |}
    |""" . stripMargin
  }
  // FIXME - much more here
}


class CodeGen(val stream: OutputStream) {
  def apply(schema: Seq[TypeCoder]) = {
    val pw = new PrintWriter(stream)

    val warning = "/* AUTOGENERATED by VL4S - do not edit by hand */\n"

    pw.print(warning)
    pw.print("\npackage uk.rwpenney.vl4s\n")

    schema.foreach { defn =>
      pw.print("\n")
      pw.print(defn.toCode)
    }

    pw.print("\n" + warning)
    pw.close()
  }
}


object CodeGen {
  def toCodeable(schema: VLschema): Seq[TypeCoder] = {
    schema.types.map {
      case enum: VLenumDefn =>  new EnumCoder(enum)
      case op: VLopDefn =>      new OperatorCoder(op)
    }
  }

  // Conversion for VL properties which class with Scala reserved words
  val mapReserved = Map(
    "type" -> "vtype"
  )

  val mapVLtypes = Map(
    "array" ->    "Seq[Any]", // FIXME - extract element type
    "boolean" ->  "Boolean",
    "number" ->   "Float",
    "object" ->   "Any",      // FIXME - check appropriateness
    "string" ->   "String"
  )

  def cleanClassName(orig: String): String =
    orig.map {
      case '<' => '_'
      case '>' => '_'
      case c =>   c
    }
}
